<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css" integrity="sha256-xejo6yLi6vGtAjcMIsY8BHdKsLg7QynVlFMzdQgUuy8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"laxiflora.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.12.3","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜尋...","empty":"我們無法找到任何有關 ${query} 的搜索結果","hits_time":"${hits} 找到 ${time} 個結果","hits":"找到 ${hits} 個結果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="laxiflora的小天地">
<meta property="og:url" content="https://laxiflora.github.io/index.html">
<meta property="og:site_name" content="laxiflora的小天地">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="劉宇承">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://laxiflora.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-TW","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>laxiflora的小天地</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切換導航欄" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">laxiflora的小天地</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">前進軟體工程師的練功之路</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>標籤</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>歸檔</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目錄
        </li>
        <li class="sidebar-nav-overview">
          本站概要
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">劉宇承</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">標籤</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="回到頂端">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://laxiflora.github.io/2023/04/29/%E6%B7%BA%E8%AB%87c-c-%E7%9A%84VLA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="劉宇承">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/29/%E6%B7%BA%E8%AB%87c-c-%E7%9A%84VLA/" class="post-title-link" itemprop="url">淺談c/c++的VLA</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2023-04-29 17:01:42 / 修改時間：22:26:37" itemprop="dateCreated datePublished" datetime="2023-04-29T17:01:42+08:00">2023-04-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="在C-傳遞二維VLA的難題"><a href="#在C-傳遞二維VLA的難題" class="headerlink" title="在C++傳遞二維VLA的難題"></a>在C++傳遞二維VLA的難題</h1><p>在寫某題leetcode時，碰到了需要宣告2維陣列，且陣列大小是變數的狀況。因為自己本身習慣使用VLA(variable-length arrays)，所以理所當然的宣告了二維陣列，並將他丟入函式處理，格式如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> y_axis, <span class="type">bool</span> map[][y_axis])</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> map[x_axis][y_axis];</span><br><span class="line"><span class="built_in">foo</span>(y_axis, map)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>值得注意的是，如果把argument map放在y_axis前面的話，會造成編譯器先看到map然後無法解讀y_axis (未宣告的變數)</p>
</blockquote>
<p>這個方法在C中行得通，然而在C++會跳出錯誤訊息:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: use of parameter outside function body before ‘]’ token</span><br><span class="line">    <span class="number">3</span> | <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> array[][n])</span></span>&#123;</span><br></pre></td></tr></table></figure>

<p>若是把map改成bool**作為參數，則會:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> y_axis, <span class="type">bool</span>** map)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">error: cannot convert ‘<span class="built_in">int</span> (*)[n]’ to ‘<span class="type">int</span>**’</span><br><span class="line">   <span class="number">11</span> |     <span class="built_in">foo</span>(n, array);</span><br></pre></td></tr></table></figure>


<p>但如果陣列的大小是常數，卻可以編譯通過</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> (*array)[<span class="number">3</span>])</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    std::cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> array[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">foo</span>(n, array);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看來問題出在C++中，多維陣列的local宣告不可用變數作為參數(VLA)</p>
<p>嗯? 你說你在C++可以用<code>int array[m][n];</code>宣告成功並使用，只是不能丟入函數? 這其實只是編譯器給你行方便而已，GPT給出了回答:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C++ does not support variable-length arrays (VLA) as a language feature, unlike C99 which introduced VLAs as a standard feature. However, some C++ compilers may offer support for VLAs as an extension, allowing you to declare and use them in your code.</span><br><span class="line"></span><br><span class="line">The ability to declare a VLA 2D array like int array[m][n] in C++ may be possible because some C++ compilers may allow it as an extension to the language. However, the behavior of such extensions can vary between different compilers, and they may not be portable across different platforms or architectures.</span><br><span class="line"></span><br><span class="line">It&#x27;s important to note that relying on such extensions may not be the best approach for writing portable and maintainable C++ code. Instead, it&#x27;s recommended to use alternative approaches for dynamically allocating memory, such as using the std::vector container or dynamic memory allocation with the new and delete operators. These approaches provide more portable and flexible solutions for dynamically allocating memory in C++.</span><br></pre></td></tr></table></figure>


<h1 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h1><p>C++相對於把動態變換大小的資料存放在stack，更鼓勵將資料放在heap中，方法是透過vector STL或是new pointer:</p>
<blockquote>
<p>C++中vector元素的存放位置是heap，push_back元素時實際上new了一個新object</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用new的</span></span><br><span class="line"><span class="type">int</span>** a = <span class="keyword">new</span> <span class="type">int</span>*[x_axis];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; x_axis; ++i)</span><br><span class="line">    a[i] = <span class="keyword">new</span> <span class="type">int</span>[y_axis];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用vector，因為vector是動態延展大小，所以這裡包含了輸入</span></span><br><span class="line">vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; a;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x_axis;i++)&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; newRow;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;y_axis;j++)&#123;</span><br><span class="line">        <span class="type">int</span> input;</span><br><span class="line">        cin&gt;&gt;input;</span><br><span class="line">        newRow.<span class="built_in">push_back</span>(input);</span><br><span class="line">    &#125;</span><br><span class="line">    a.<span class="built_in">push_back</span>(newRow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="為什麼會這樣"><a href="#為什麼會這樣" class="headerlink" title="為什麼會這樣"></a>為什麼會這樣</h1><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1887097/why-arent-variable-length-arrays-part-of-the-c-standard">這裡給出了解釋</a>，大致是說如果直接宣告的話，第一可能有stack overflow的風險(將stack allocation交由輸入者決定是危險的)，第二則是對於編譯器實作會有額外的負擔，必須在run time才能知道stack要被allocate多少大小</p>
<p>當然，這也有一定的trade-off，如果我們將資料放在heap中，相比於記憶體地址連續的stack，或多或少會傷害到cache performance(當然還是要看CPU的實作)，且要allocate in stack只要延伸sp指的位置就好，不像<code>new</code>還要跟記憶體互動</p>
<p>不過，傳統的C99是允許VLA的，現今常見的編譯器(gcc, clang等)都有支援基本的VLA，但要注意的是<em>這不是C++的standard</em>，而是來自於編譯器的extention，將C++的宣告方法轉成C風格、支援VLA的格式</p>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>如果要用C++寫程式，就善用STL容器吧。</p>
<p>C++與C對於相同的概念，有不同的實作方式：C++希望設計師使用他們提供的解方(STL)來解決問題；C則更相信程式設計師知道自己在幹嘛(有stack overflow的風險)，但提供自由與看似方便的宣告方法的背後，就是程式莫名崩潰的風險。</p>
<p>別被C允許VLA的開發方式慣壞了，為了讓程式更安全並兼顧速度，根據使用狀況判斷使用heap還是stack來存放資料是好習慣</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://laxiflora.github.io/2022/12/21/111-1-%E4%BA%A4%E5%A4%A7%E7%B6%B2%E8%B7%AF%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="劉宇承">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/21/111-1-%E4%BA%A4%E5%A4%A7%E7%B6%B2%E8%B7%AF%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/" class="post-title-link" itemprop="url">111-1 交大網路程式設計</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2022-12-21 02:41:19 / 修改時間：02:42:43" itemprop="dateCreated datePublished" datetime="2022-12-21T02:41:19+08:00">2022-12-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>只簡介作業的眉角，畢竟課堂的本體是作業orz</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://laxiflora.github.io/2022/12/21/%E4%BA%A4%E5%A4%A7%E7%B6%B2%E8%B7%AF%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="劉宇承">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/21/%E4%BA%A4%E5%A4%A7%E7%B6%B2%E8%B7%AF%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/" class="post-title-link" itemprop="url">交大網路程式設計</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2022-12-21 02:38:50 / 修改時間：02:39:41" itemprop="dateCreated datePublished" datetime="2022-12-21T02:38:50+08:00">2022-12-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://laxiflora.github.io/2022/10/15/char-%E7%9A%84%E5%A5%A7%E7%A7%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="劉宇承">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/15/char-%E7%9A%84%E5%A5%A7%E7%A7%98/" class="post-title-link" itemprop="url">char*的奧秘</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2022-10-15 02:41:50 / 修改時間：03:58:44" itemprop="dateCreated datePublished" datetime="2022-10-15T02:41:50+08:00">2022-10-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>這篇文主要想要強調的就是，char*作為一個指標，紀錄的是記憶體位址，若指向的記憶體地址沒有被分配，是不可以直接用strcpy的</p>
<p>char[]其實就是一個數組，雖然看似跟char*一樣，但兩者的邏輯不同</p>
<h2 id="char"><a href="#char" class="headerlink" title="char[]"></a>char[]</h2><p><code>char a[] = &quot;KKK&quot;</code> 其實等同於<code>char a[] = &#123;&#39;K&#39;,&#39;K&#39;,&#39;K&#39;,&#39;\0&#39;&#125;</code><br>如果用vs code滑上去看，會發現它其實就是char a[4]<br><img src="/../images/20221015_1.png"></p>
<p>這類型的變數在宣告時就必須給定字元，且後續長度不可修改。</p>
<blockquote>
<p>即，不能用<code>char a[] = &quot;KKK&quot;;  a = &quot;KKKKK&quot;;</code></p>
</blockquote>
<p>這時候它的操作等同於char[n]，要改變其中任意「字元」都是可行的(此變數已經作為array被分配在stack中)<br>但當然如果把最後的’\0’換成其他字元，<code>printf(&quot;%s&quot;)</code>會印出奇怪的東西</p>
<p>至於char* argv[]，同理其實只是等同於<code>char* argv[n] = &#123;&#39;string1&#39;,&#39;string2&#39;,...&#125;</code>而已</p>
<p>要注意的是不可以直接把整個array改成其他字串，在C語言規範中arrays並非modifiable l-values</p>
<p>如果要修改這類的char陣列，須使用<code>strcpy</code> (用malloc&#x2F;new出來的char array同理)</p>
<p>這類char陣列的size是根據字元數變動的</p>
<h2 id="char-1"><a href="#char-1" class="headerlink" title="char*"></a>char*</h2><p>顧名思義，他其實是字元指標，指向某個字串常數的指標。</p>
<p>C&#x2F;C++的常數字串儲存方法是為這些字串開一個空間存放他們，當宣告</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* A = <span class="string">&quot;hey&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>時，其實就是為hey這個字串分配一個空的記憶體位置，並且將A指向這個地址。</p>
<blockquote>
<p>也就是說，如果哪天”hey”的值變動了，A的內容也會跟著變動! 同時char*可以指向任意大小的char[]，但只要char[]內容更動，char*也會受到影響</p>
</blockquote>
<p>因為這個特性，char*不同於char[]，他是可以在後天改值的，只要改變他指的地址即可。</p>
<ul>
<li>char*就是浮萍，不像char[]、malloc()出來的char*一樣攜家帶眷</li>
</ul>
<p>不過，也因為他是單單一個指向記憶體的指標，我們不能透過strcpy等函數塞整個char array給他，他的空間尚未被初始化，如果直接用strcpy很可能導致SEG Falut</p>
<p>而且因為類別正確(strcpy的確是接受char*作為參數)，所以編譯器<strong>並不會警告</strong>，新手在看文件時也會看到輸入參數是char*就傻傻地把char*丟進去了</p>
<p>最後，char*如果沒有被初始化(指向某個常數字串)而直接印出，也會SEG fault</p>
<ul>
<li>這類char指標的size是根據作業系統的位元數變動的</li>
</ul>
<h2 id="char-2"><a href="#char-2" class="headerlink" title="char *[]"></a>char *[]</h2><p>根據<a href="/2022/10/15/C-C-%E5%AE%A3%E5%91%8A%E9%96%B1%E8%AE%80%E6%B3%95/">C&#x2F;C++宣告閱讀法</a>，以下面的變數為範例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char* hard[3];</span><br></pre></td></tr></table></figure>
<p>我們可以得到他是「hard is size-3 array of pointers to char 」，也就是3個char*。因此我們我們可以套用char*的作法，hard這個變數是不能被strcpy的(不會有任何警告但會SAG fault)</p>
<h2 id="額外補充"><a href="#額外補充" class="headerlink" title="額外補充"></a>額外補充</h2><p>另一個常見的SEG fault的原因就是生命週期</p>
<p>考慮以下code</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">char</span>* in)</span>&#123;</span><br><span class="line">    <span class="type">char</span> ans[] = <span class="string">&quot;laugh&quot;</span>;</span><br><span class="line">    in = ans; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nin funct, aram = %s\n&quot;</span>,in);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">    <span class="type">char</span>* aram;</span><br><span class="line">    foo(aram);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nout funct, aram = %s\n&quot;</span>,aram);</span><br></pre></td></tr></table></figure>

<p>我們應該會期望得到輸出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in funct, aram = laugh</span><br><span class="line">out funct, aram = laugh</span><br></pre></td></tr></table></figure>

<p>但結果卻是SEG fault</p>
<p>因為ans作為foo函數的區域變數，在退出函數時就已經消滅了，當aram變數還指向他的時候，其實會出現未定義行為</p>
<p>所以如果想要讓aram保存ans的結果，最好的做法就是用malloc的，如下code</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">char</span>* in)</span>&#123;</span><br><span class="line">    <span class="type">char</span> ans[] = <span class="string">&quot;laugh&quot;</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(in,ans);  <span class="comment">//注意要改成strcpy!</span></span><br><span class="line">   <span class="comment">// in = ans; </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nin funct, aram = %s\n&quot;</span>,in);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">    <span class="type">char</span>* aram;</span><br><span class="line">    aram = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">16</span>); <span class="comment">//讓aram變成malloc變數，可以「攜家帶眷」</span></span><br><span class="line">    foo(aram);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nout funct, aram = %s\n&quot;</span>,aram);</span><br></pre></td></tr></table></figure>

<p>Note: 如果aram在丟入foo以後才malloc，仍會因為命名問題消滅造成SEG fault!!</p>
<p>如果想要在函數內進行malloc，則需要傳入aram的地址，如下code</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">char</span>** in)</span>&#123;</span><br><span class="line">    <span class="type">char</span> ans[] = <span class="string">&quot;laugh&quot;</span>;</span><br><span class="line">    *in = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">16</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(*in,ans);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nin funct, aram = %s\n&quot;</span>,*in);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">    <span class="type">char</span>* aram;</span><br><span class="line">    foo(&amp;aram); <span class="comment">//改這裡</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nout funct, aram = %s\n&quot;</span>,aram);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://laxiflora.github.io/2022/10/15/C-C-%E5%AE%A3%E5%91%8A%E9%96%B1%E8%AE%80%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="劉宇承">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/15/C-C-%E5%AE%A3%E5%91%8A%E9%96%B1%E8%AE%80%E6%B3%95/" class="post-title-link" itemprop="url">C/C++宣告閱讀法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2022-10-15 02:39:08 / 修改時間：02:40:25" itemprop="dateCreated datePublished" datetime="2022-10-15T02:39:08+08:00">2022-10-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>來源: <a target="_blank" rel="noopener" href="https://cseweb.ucsd.edu/~ricko/rt_lt.rule.html">The “right-left” rule</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://laxiflora.github.io/2022/10/10/C-pipe%E8%88%87buffer-overflow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="劉宇承">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/10/C-pipe%E8%88%87buffer-overflow/" class="post-title-link" itemprop="url">C++ pipe與buffer overflow</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2022-10-10 23:28:56" itemprop="dateCreated datePublished" datetime="2022-10-10T23:28:56+08:00">2022-10-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新於</span>
      <time title="修改時間：2022-10-11 00:15:31" itemprop="dateModified" datetime="2022-10-11T00:15:31+08:00">2022-10-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本篇主要講述C++中<code>pipe()</code>函數的相關行為</p>
<p>因為pipe的buffer大小並非無限大，如果輸入流資料量過大，很有可能會碰到buffer塞滿而輸入還沒結束的問題<br>寫了以下的code來測試pipe buffer如果塞爆了會發生甚麼事情</p>
<h1 id="實驗"><a href="#實驗" class="headerlink" title="實驗"></a>實驗</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// 創造pipe</span></span><br><span class="line">    <span class="type">int</span> my_pipe[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pipe</span>(my_pipe) == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error creating pipe\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//-------------------------</span></span><br><span class="line">    <span class="type">pid_t</span> child_id;</span><br><span class="line">    child_id = fork();</span><br><span class="line">    <span class="keyword">if</span>(child_id == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Fork error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 創造一個子process，將buffer塞爆</span></span><br><span class="line">    <span class="keyword">if</span>(child_id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(my_pipe[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">dup2</span>(my_pipe[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        string some = <span class="string">&quot;something&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000000000000000</span>;i++)&#123;</span><br><span class="line">            cout&lt;&lt;some;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Chind,finished&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//---------------------------------</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="type">int</span> aaa = fork();</span><br><span class="line">        <span class="comment">// 再創造一個子process，讓他先sleep 4秒以後再嘗試在已經被塞爆的buffer寫入</span></span><br><span class="line">        <span class="keyword">if</span>(aaa == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">4</span>);</span><br><span class="line">            <span class="built_in">close</span>(my_pipe[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1999</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Child2 round &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                <span class="built_in">write</span>(my_pipe[<span class="number">1</span>],<span class="string">&quot;NP&quot;</span>,<span class="built_in">sizeof</span>(<span class="string">&quot;NP&quot;</span>));  <span class="comment">// is stuck because of the fullness of pipe</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//----------------------------</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原本的父process，先sleep 10秒讓我們觀察child process被塞爆的現象再read一些東西來疏通pipe，但這樣的量不足以讀完所有的input</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">close</span>(my_pipe[<span class="number">1</span>]); <span class="comment">// parent doesn&#x27;t write</span></span><br><span class="line"></span><br><span class="line">            <span class="type">char</span> reading_buf[<span class="number">1000</span>]=&#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">                <span class="built_in">read</span>(my_pipe[<span class="number">0</span>], reading_buf, <span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等待第一次fork出來的子process</span></span><br><span class="line">    <span class="built_in">wait</span>(&amp;child_id);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//這行永遠不會印出來，因為子process永遠不會輸出完成而結束</span></span><br><span class="line">    cout&lt;&lt;my_pipe[<span class="number">0</span>]&lt;&lt;my_pipe[<span class="number">1</span>]; <span class="comment">//3,4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>實際編譯執行後，出現以下結果<br><img src="/../images/20221010_2.png" alt="upload successful"><br>Child2卡在第1897次輸出就寫不下去了，當然第一個process也是卡住的狀態(見Ps)</p>
<h1 id="Pipe特性"><a href="#Pipe特性" class="headerlink" title="Pipe特性"></a>Pipe特性</h1><p>從這個小實驗可以知道一些事情</p>
<ul>
<li><p>pipe的buffer有限，是會被塞爆的</p>
</li>
<li><p>原生的pipe如果被寫滿，會讓想繼續寫入的<strong>所有process</strong>被卡住不能繼續執行，直到pipe被讀取</p>
<ul>
<li>不可以wait process完整寫入發signal以後才fork另一個process再讀取，這樣很可能導致整個程式卡死<br>    - 如果卡住的process太多，可能會讓父process再也fork不出東西來讓本該讀取的process去接，造成整個程式卡死</li>
</ul>
</li>
<li><p>要注意針對大資料的處理，pipe應該要有個”抒發管道”，不能期待他真的裝下全世界</p>
</li>
</ul>
<h2 id="補充"><a href="#補充" class="headerlink" title="補充"></a>補充</h2><p>我另外做了一個反向實驗:<br>    讓輸入資料的process延遲輸入，而讀取的process開始讀空的pipe，得到以下心得</p>
<ul>
<li>讀取端會等read(fd,char* buffer,int size)裡面的size被填滿才會執行接下來的動作<ul>
<li>想到以前上課老師說的，只要<strong>還有process 對pipe的輸入端還未關閉</strong>，讀取端就會一直認為有東西要進來，而呆呆地等 -&gt; 關不用的stream很重要!</li>
</ul>
</li>
</ul>
<p>P.S<br>測試這個東西的時候還有用背景執行，創造了不少卡著的process<br><img src="/../images/20221010_1.png"><br>其中相連的pid可以看出來是同一個程式來的，原本的父process，連帶所有child process都無法被正常結束…</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://laxiflora.github.io/2022/10/09/%E7%94%A8std-string%E5%81%9Astrtok/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="劉宇承">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/09/%E7%94%A8std-string%E5%81%9Astrtok/" class="post-title-link" itemprop="url">用std::string做strtok</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2022-10-09 17:16:11 / 修改時間：17:36:08" itemprop="dateCreated datePublished" datetime="2022-10-09T17:16:11+08:00">2022-10-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>參考資料: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/289347/using-strtok-with-a-stdstring">stackoverflow</a></p>
<h1 id="用std-string做strtok"><a href="#用std-string做strtok" class="headerlink" title="用std::string做strtok"></a>用std::string做strtok</h1><p>由於C++的string type並不支援strtok的功能，所以如果想要將C++的string做切段，有以下幾種方法:</p>
<h2 id="法1-用istringstream"><a href="#法1-用istringstream" class="headerlink" title="法1: 用istringstream"></a>法1: 用istringstream</h2><p>使用<a target="_blank" rel="noopener" href="https://cplusplus.com/reference/sstream/istringstream/istringstream/">stringstream類別</a>，使用方法就像C++風格的iostream一樣，只是這個stream不是stdin&#x2F;stdout，也不是fstream，而是將string的內容倒入一個stream (因此不具有fd–待查證)。</p>
<p>將要切割的字串倒入stream以後，再用getline中的Delimiter參數做為切割標準即可<br>參考程式碼片段如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">char</span> delimiter)</span></span>&#123;</span><br><span class="line">   vector&lt;string&gt; tokens;</span><br><span class="line">   string token;</span><br><span class="line">   <span class="function">istringstream <span class="title">tokenStream</span><span class="params">(s)</span></span>;</span><br><span class="line">   <span class="keyword">while</span> (<span class="built_in">getline</span>(tokenStream, token, delimiter))&#123;</span><br><span class="line">      tokens.<span class="built_in">push_back</span>(token);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> tokens;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// tokens vector裝的是切割完的string</span></span><br></pre></td></tr></table></figure>


<h2 id="法2-先把string轉成char-以後再切割"><a href="#法2-先把string轉成char-以後再切割" class="headerlink" title="法2: 先把string轉成char*以後再切割"></a>法2: 先把string轉成char*以後再切割</h2><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/289347/using-strtok-with-a-stdstring">參考資料</a><br>如果要將string轉換成char*，可以透過<code>string.c_str()</code>函數</p>
<p>這個方法其實不太推薦，他是把C++風格棄掉，強制使用strtok來處理字串<br>參考程式碼片段如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//given string str as a string needed to slice</span></span><br><span class="line"><span class="type">char</span> *dup = <span class="built_in">strdup</span>(str.<span class="built_in">c_str</span>());</span><br><span class="line">token = <span class="built_in">strtok</span>(dup, <span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(dup);</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://laxiflora.github.io/2022/08/17/ML-2021-12-1-%E5%A2%9E%E5%BC%B7%E5%BC%8F%E5%AD%B8%E7%BF%92%E8%B7%9F%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92%E4%B8%80%E6%A8%A3%E9%83%BD%E6%98%AF%E4%B8%89%E5%80%8B%E6%AD%A5%E9%A9%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="劉宇承">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/17/ML-2021-12-1-%E5%A2%9E%E5%BC%B7%E5%BC%8F%E5%AD%B8%E7%BF%92%E8%B7%9F%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92%E4%B8%80%E6%A8%A3%E9%83%BD%E6%98%AF%E4%B8%89%E5%80%8B%E6%AD%A5%E9%A9%9F/" class="post-title-link" itemprop="url">ML_2021_12-1 增強式學習跟機器學習一樣都是三個步驟</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2022-08-17 13:15:48 / 修改時間：19:31:50" itemprop="dateCreated datePublished" datetime="2022-08-17T13:15:48+08:00">2022-08-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://laxiflora.github.io/2022/08/15/ML-2021-11-1-%E6%A6%82%E8%BF%B0%E9%A0%98%E5%9F%9F%E8%87%AA%E9%81%A9%E6%87%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="劉宇承">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/15/ML-2021-11-1-%E6%A6%82%E8%BF%B0%E9%A0%98%E5%9F%9F%E8%87%AA%E9%81%A9%E6%87%89/" class="post-title-link" itemprop="url">ML_2021_11-1 概述領域自適應</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2022-08-15 01:58:17" itemprop="dateCreated datePublished" datetime="2022-08-15T01:58:17+08:00">2022-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新於</span>
      <time title="修改時間：2022-08-17 19:31:50" itemprop="dateModified" datetime="2022-08-17T19:31:50+08:00">2022-08-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Train跟testing data之間可能會有不同的分佈 -&gt; <strong>domain shift</strong></p>
<p>ex. 用黑白圖片訓練數字辨識，但測試資料使用彩色圖片，則命中率會大幅降低</p>
<h1 id="Domain-shift的種類"><a href="#Domain-shift的種類" class="headerlink" title="Domain shift的種類"></a>Domain shift的種類</h1><ul>
<li>不只是輸入資料的特性不合</li>
<li>可能輸出的資料，其機率分佈不一樣</li>
<li>或是也許在測試資料裡面，雖然圖樣跟訓練資料很像，但是它所代表的意涵卻不一樣<br><img src="/../images/20220817_1.png"></li>
</ul>
<h1 id="Domain-adaptation"><a href="#Domain-adaptation" class="headerlink" title="Domain adaptation"></a>Domain adaptation</h1><ul>
<li>可以看作是transfer learning的一種</li>
<li>我們會需要對target domain有一些了解</li>
</ul>
<h2 id="Case-1-有target-domain的labeled資料但資料量很少"><a href="#Case-1-有target-domain的labeled資料但資料量很少" class="headerlink" title="Case 1:有target domain的labeled資料但資料量很少"></a>Case 1:有target domain的labeled資料但資料量很少</h2><ul>
<li>用類似BERT的fine-tune方法來微調一下model</li>
<li>但target domain資料量很少，所以很容易overfitting<ul>
<li>限制fine-tune前後的參數變化量<br>    - 降低lr<br>    - 限制epoch數</li>
</ul>
</li>
</ul>
<h2 id="Case-2-有一大堆target-domain的unlabeled資料"><a href="#Case-2-有一大堆target-domain的unlabeled資料" class="headerlink" title="Case 2:有一大堆target domain的unlabeled資料"></a>Case 2:有一大堆target domain的unlabeled資料</h2><ul>
<li>本課的討論重點</li>
<li>在實務上比較有常發生</li>
<li>Idea:用一個feature extractor把source跟target domain的不同點刪除，擷取出共同的部分<ul>
<li>Ex.數字辨識，學習去忽略圖片顏色</li>
</ul>
</li>
</ul>
<h3 id="Domain-Adversarial-training"><a href="#Domain-Adversarial-training" class="headerlink" title="Domain Adversarial training"></a>Domain Adversarial training</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li><p>我們會訓練出一個new image classifier model，其中前半部分是feature extractor，後半部則是label predictor<br><img src="/../images/20220817_2.png"></p>
</li>
<li><p>我們會希望feature extractor的輸出（上圖右下角的分佈圖），source跟target domain的分佈看不出差異</p>
</li>
<li><p>由feature extractor跟domain classifier互相對抗，將feature extractor的輸出送到domain classifier，domain classifier要想辦法辨認出這個輸出是來自source還是target domain</p>
</li>
<li><p>feature extractor -&gt; Generator &amp; domain classifier -&gt; Discriminator</p>
</li>
<li><p>但這樣對於feature extractor優勢太大，因為只要他都輸出0，就可以讓domain classifier被輕鬆騙過去 -&gt; 讓label Predictor也加入戰局</p>
</li>
</ul>
<h4 id="計算方法"><a href="#計算方法" class="headerlink" title="計算方法"></a>計算方法</h4><p>令</p>
<ol>
<li>Feature extractor的參數為$\theta_f$</li>
<li>Label Predictor的參數為$\theta_p$</li>
<li>Domain Classifier的參數為$\theta_d$</li>
<li>輸出圖片預測結果與真實結果的loss(cross entropy)為$L$</li>
<li>Domain Classifier二元分類器的輸出loss為$L_d$</li>
</ol>
<p>因為我們同時希望Label Predictor分類越正確越好，又同時希望domain classifier能被騙過。則可以得出一個最佳化feature extractor的公式（非正確，勿照抄）<br>$$<br>\theta_f^* &#x3D; min_{\theta_f}\ L-L_d<br>$$</p>
<p>問題來了，如果我們直接套用這個公式，會導致$L_d$越大越好（也就是讓domain classifier的loss飆高），這可能讓feature extractor變成努力讓domain classifier把target看成source，source看成target，而這也是某種程度上的分隔開兩個domain</p>
<p>如何改善公式，留給大家思考orz</p>
<p>domain adversarial training的效果拔群<br><img src="/../images/20220817_3.png"></p>
<h3 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a>Limitation</h3><p><img src="/../images/20220817_5.png"><br>由上面的公式，我們可以練出上圖兩種類型的model滿足上面的公式，但是可以明顯看出，右邊的分佈會比左邊還好</p>
<p>我們雖然不知道橘色(target domain)的label為何，但我們知道藍色(source)資料的分界線，因此我們要在這樣的前提下，想辦法也讓橘色的資料被該分界線劃清</p>
<ul>
<li>有很多相關方法<ul>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1802.08735">參考文獻：DIRT-T</a></li>
<li>一種簡單的方向是確保unlabeled data丟入label predictor後輸出的分佈越集中越好<br><img src="/../images/20220817_6.png"></li>
</ul>
</li>
</ul>
<h2 id="Case-3：雖然Target-domain-unlabeled-data很多，但Source跟Target-domain的class集合不同"><a href="#Case-3：雖然Target-domain-unlabeled-data很多，但Source跟Target-domain的class集合不同" class="headerlink" title="Case 3：雖然Target domain unlabeled data很多，但Source跟Target domain的class集合不同"></a>Case 3：雖然Target domain unlabeled data很多，但Source跟Target domain的class集合不同</h2><p>到目前為止，我們都假設target跟source domain的類別集合是一樣的</p>
<p>如果類別集合不同，則硬要align data可能會反導致兩個無關的class被綁在一起 $\rightarrow$ <strong>Universal domain adaptation</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://openaccess.thecvf.com/content_CVPR_2019/html/You_Universal_Domain_Adaptation_CVPR_2019_paper.html">參考文獻</a></li>
</ul>
<h2 id="Case-4：Target-domain-unlabeled-data也很少"><a href="#Case-4：Target-domain-unlabeled-data也很少" class="headerlink" title="Case 4：Target domain unlabeled data也很少"></a>Case 4：Target domain unlabeled data也很少</h2><ul>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1909.13231">Testing time training(TTT)</a></li>
</ul>
<h2 id="Case-5：我啥都不知道QQ"><a href="#Case-5：我啥都不知道QQ" class="headerlink" title="Case 5：我啥都不知道QQ"></a>Case 5：我啥都不知道QQ</h2><ul>
<li>Domain Generalization<ul>
<li>訓練資料豐富，包含各種domain（ex. 貓狗分類，除了真貓真狗以外還有素描、卡通畫風）<br>    	- <a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/8578664">參考文獻</a><br>    - 訓練資料不豐富，但測試資料很豐富(有點像想辦法做data augmentation)<br>    	- <a target="_blank" rel="noopener" href="https://arxiv.org/abs/2003.13216">參考文獻</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://laxiflora.github.io/2022/08/11/ML-2021-10-2-%E9%A1%9E%E7%A5%9E%E7%B6%93%E7%B6%B2%E8%B7%AF%E8%83%BD%E5%90%A6%E8%BA%B2%E9%81%8E%E4%BA%BA%E9%A1%9E%E6%B7%B1%E4%B8%8D%E8%A6%8B%E5%BA%95%E7%9A%84%E6%83%A1%E6%84%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="劉宇承">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/11/ML-2021-10-2-%E9%A1%9E%E7%A5%9E%E7%B6%93%E7%B6%B2%E8%B7%AF%E8%83%BD%E5%90%A6%E8%BA%B2%E9%81%8E%E4%BA%BA%E9%A1%9E%E6%B7%B1%E4%B8%8D%E8%A6%8B%E5%BA%95%E7%9A%84%E6%83%A1%E6%84%8F/" class="post-title-link" itemprop="url">ML_2021_10-2 類神經網路能否躲過人類深不見底的惡意?</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2022-08-11 16:26:19" itemprop="dateCreated datePublished" datetime="2022-08-11T16:26:19+08:00">2022-08-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新於</span>
      <time title="修改時間：2022-08-15 02:00:01" itemprop="dateModified" datetime="2022-08-15T02:00:01+08:00">2022-08-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在前面的攻擊，是假設我們知道模型的weights，這類攻擊稱為White box attack</p>
<p>白箱攻擊非常簡單，盡量不要暴露parameters</p>
<p>下面課程前半部以圖片辨識為例介紹</p>
<h1 id="Black-box-attack"><a href="#Black-box-attack" class="headerlink" title="Black box attack"></a>Black box attack</h1><h2 id="1-Proxy-network"><a href="#1-Proxy-network" class="headerlink" title="1. Proxy network"></a>1. Proxy network</h2><h3 id="a-原理"><a href="#a-原理" class="headerlink" title="a. 原理"></a>a. 原理</h3><p>我們雖然不知道想攻擊的模型的參數，但我們可以透過用同樣一批訓練資料，練出一個自己的網路。當我們能透過白箱攻擊讓Proxy network出現漏洞，則我們也有可能可以用同樣的方式讓想攻擊的network淪陷</p>
<h3 id="b-若無訓練資料"><a href="#b-若無訓練資料" class="headerlink" title="b. 若無訓練資料"></a>b. 若無訓練資料</h3><p>如果沒有訓練資料，也可以透過自己準備一批資料，餵給想攻擊的模型，讓他吐出一堆輸出，把輸入與輸出綁成成對資料，再拿去訓練自己的proxy network</p>
<p><img src="/../images/20220814_1.png" alt="上圖是用不同網路去攻擊各網路的accuracy，對角線因為是為白箱攻擊，所以不計入(能破proxy必能破attacked)"></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1611.02770">上圖來源(相關論文)</a></li>
</ul>
<h3 id="c-Advanced-technique-Ensemble-attack"><a href="#c-Advanced-technique-Ensemble-attack" class="headerlink" title="c. Advanced technique: Ensemble attack"></a>c. Advanced technique: Ensemble attack</h3><ul>
<li>透過使用Ensemble model有效提高攻擊的強度</li>
</ul>
<p><img src="/../images/20220814_2.png"><br>上圖縱列是指拿掉甚麼network，橫列則是被攻擊的network，如「-ResNet-152」那列就是結合除了ResNet-152以外的4個network所訓練出來的proxy network對各網路的攻擊結果；其中非對角線部分因為已在proxy network被訓練過，均視為白箱攻擊，不計入(0%)</p>
<h1 id="為何黑箱攻擊如此容易成功"><a href="#為何黑箱攻擊如此容易成功" class="headerlink" title="為何黑箱攻擊如此容易成功?"></a>為何黑箱攻擊如此容易成功?</h1><ul>
<li><strong>至今仍然還沒有確定性的答案</strong></li>
<li>多數人相信是因為模型之間存在著相似性，如下圖<br><img src="/../images/20220814.png"></li>
</ul>
<p>圖片為一個高維向量，圖片的值是為原點，圖片的橫軸為可以讓攻擊成功的維度變化量，縱軸則為其他維度的偏移量。</p>
<p>可以發現，能在VGG-16攻擊成功的維度偏移方向，與其餘4種network均很相近。也就是說，能找到在VGG-16攻擊成功的圖片偏移方向與大小，在其他network上均大同小異。</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1611.02770.pdf">論文來源</a></p>
</li>
<li><p>目前有一群人認為：或許Adversarial attack會成功，不是因為模型的問題，而是資料本身的特徵真的就是長那樣 $\rightarrow$ 或許資料量更大就能避免</p>
</li>
</ul>
<h1 id="One-pixel-attack"><a href="#One-pixel-attack" class="headerlink" title="One pixel attack"></a>One pixel attack</h1><p>只動圖片裡的1 pixel就達成攻擊目的</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1710.08864">來源論文</a></li>
<li>目前效果有限</li>
</ul>
<h1 id="Universal-Adversarial-Attack"><a href="#Universal-Adversarial-Attack" class="headerlink" title="Universal Adversarial Attack"></a>Universal Adversarial Attack</h1><ul>
<li>針對一個network的全方位攻擊方式</li>
</ul>
<p>針對不同的圖片輸入，客製化出一個攻擊方式</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1610.08401">來源論文</a></li>
</ul>
<h1 id="Adversarial-reprogramming"><a href="#Adversarial-reprogramming" class="headerlink" title="Adversarial reprogramming"></a>Adversarial reprogramming</h1><p>有點像殭屍寄生，讓原本的model輸出非他原本訓練想要的結果<br><img src="/../images/20220815_7.png" alt="upload successful"></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1806.11146">來源論文</a></li>
</ul>
<h1 id="Backdoor-in-model"><a href="#Backdoor-in-model" class="headerlink" title="Backdoor in model"></a>Backdoor in model</h1><ul>
<li>在訓練階段就展開攻擊</li>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1804.00792">來源論文</a></li>
<li>在訓練資料就放入attacked image，讓模型練完以後看似正常，卻只對單一類型圖片會出現問題，如同後門</li>
</ul>
<p>$rightarrow$ 若這樣的技術成熟，公開資料集將會變得不安全</p>
<hr>
<h1 id="其他領域的攻擊應用"><a href="#其他領域的攻擊應用" class="headerlink" title="其他領域的攻擊應用"></a>其他領域的攻擊應用</h1><h2 id="1-Speech-processing"><a href="#1-Speech-processing" class="headerlink" title="1. Speech processing"></a>1. Speech processing</h2><ul>
<li>Detect synthesized speech：抓出合成的聲音訊號</li>
</ul>
<p>攻擊者刻意在合成音裡面加入雜訊，讓機器以為那是原聲</p>
<h2 id="2-NLP"><a href="#2-NLP" class="headerlink" title="2. NLP"></a>2. NLP</h2><p>文字輸入，進行機器QA</p>
<p>刻意在文字中加入雜訊，讓機器搞錯重點</p>
<ul>
<li>範例：(<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1908.07125">https://arxiv.org/abs/1908.07125</a>)</li>
</ul>
<h2 id="3-人臉辨識：真實世界攻擊"><a href="#3-人臉辨識：真實世界攻擊" class="headerlink" title="3. 人臉辨識：真實世界攻擊"></a>3. 人臉辨識：真實世界攻擊</h2><ul>
<li>既然能在虛擬世界中對圖片加工造成機器判別錯誤，當然也有可能在現實世界中對人臉加裝配件對機器造成攻擊</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~sbhagava/papers/face-rec-ccs16.pdf">來源論文</a><br><img src="/../images/20220815_5.png"></p>
<ul>
<li>現實世界需要考慮諸多因素<ul>
<li>攝影角度 $\rightarrow$ universal attack(?<br>    - 解析度問題<br>    - 眼鏡印製的色差問題</li>
</ul>
</li>
</ul>
<p>除此以外，也有針對交通號誌的攻擊，讓自駕車變得困難<br><img src="/../images/20220815_6.png"></p>
<hr>
<h1 id="Defence"><a href="#Defence" class="headerlink" title="Defence"></a>Defence</h1><ul>
<li>防禦分為兩種<ul>
<li>主動防禦</li>
<li>被動防禦</li>
</ul>
</li>
</ul>
<h2 id="1-被動防禦"><a href="#1-被動防禦" class="headerlink" title="1. 被動防禦"></a>1. 被動防禦</h2><ul>
<li><p>network不動，在圖片丟入之前放一個Filter，來隔絕雜訊</p>
</li>
<li><p>一種簡單的做法是刻意把圖片模糊化，讓原本可以讓攻擊成功的維度偏移量改變</p>
<ul>
<li>但同時也會降低原始正常圖片的辨識度</li>
</ul>
</li>
</ul>
<h3 id="a-更多作法"><a href="#a-更多作法" class="headerlink" title="a. 更多作法"></a>a. 更多作法</h3><ul>
<li><p>圖片壓縮(刻意失真)</p>
</li>
<li><p>讓Generator重新把input image重新畫一遍</p>
<ul>
<li>是有方法讓Generator產生一樣東西的，但因為generator沒看過雜訊，會產生不出來<br>    - <a target="_blank" rel="noopener" href="https://arxiv.org/abs/1805.06605">相關文獻</a></li>
</ul>
</li>
<li><p>被動防禦(模糊化)也可以視為在network前面加入一層，所以一旦被知道以後，防禦力將會大減 $\rightarrow$ 隨機化</p>
</li>
</ul>
<h3 id="b-Randomization"><a href="#b-Randomization" class="headerlink" title="b. Randomization"></a>b. Randomization</h3><ul>
<li>把圖片隨機resize,padded一些背景之後再丟入network</li>
</ul>
<p><img src="/../images/20220814_8.png" alt="upload successful"></p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1711.01991">相關文獻</a></p>
</li>
<li><p>仍然有可能被攻破，抓出所有可能以後用universal attack</p>
</li>
</ul>
<h2 id="2-主動防禦"><a href="#2-主動防禦" class="headerlink" title="2. 主動防禦"></a>2. 主動防禦</h2><h3 id="a-Adversarial-training"><a href="#a-Adversarial-training" class="headerlink" title="a. Adversarial training"></a>a. Adversarial training</h3><ul>
<li><p>在訓練階段就讓模型被攻擊</p>
</li>
<li><p>把原始圖片做成attacked image後標上正確label以後再丟入model</p>
</li>
<li><p>某種程度上就是data augmentation (有洞就補洞)</p>
<ul>
<li>就算不會被攻擊，也會有人用這樣的方式來強化model(降低overfitting可能性)</li>
</ul>
</li>
<li><p>訓練過程需要大量訓練資源，且如果碰到沒補過洞的attack algorithm，依然會被攻破</p>
</li>
<li><p>有方法是不需額外計算的情況下做到adversarial training</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1904.12843">相關文獻</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一頁"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">劉宇承</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 強力驅動
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
