<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css" integrity="sha256-xejo6yLi6vGtAjcMIsY8BHdKsLg7QynVlFMzdQgUuy8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"laxiflora.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.12.3","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜尋...","empty":"我們無法找到任何有關 ${query} 的搜索結果","hits_time":"${hits} 找到 ${time} 個結果","hits":"找到 ${hits} 個結果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="laxiflora的小天地">
<meta property="og:url" content="https://laxiflora.github.io/index.html">
<meta property="og:site_name" content="laxiflora的小天地">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="劉宇承">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://laxiflora.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-TW","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>laxiflora的小天地</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切換導航欄" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">laxiflora的小天地</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">前進軟體工程師的練功之路</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>標籤</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>歸檔</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目錄
        </li>
        <li class="sidebar-nav-overview">
          本站概要
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">劉宇承</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">標籤</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="回到頂端">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://laxiflora.github.io/2023/05/17/scanf%E8%88%87stdin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="劉宇承">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/17/scanf%E8%88%87stdin/" class="post-title-link" itemprop="url">scanf與stdin</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2023-05-17 20:14:12 / 修改時間：21:23:13" itemprop="dateCreated datePublished" datetime="2023-05-17T20:14:12+08:00">2023-05-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在一個美好的coding日，你希望可以從stdin中讀取一個數字以及一個字元，於是你寫了下面這段code:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%c&quot;</span>,&amp;a,&amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;|%d  %c|&quot;</span>, a, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>並輸入了<code>32\nX</code>做為測試(‘\n’代指換行)，卻發現他的輸出不是|32 X|，而是|32 \n|</p>
<h1 id="發生了甚麼事"><a href="#發生了甚麼事" class="headerlink" title="發生了甚麼事"></a>發生了甚麼事</h1><p>因為scanf(“%c”)在執行期間會「無條件」吃下下一個字元並返回，而scanf(“%d”)也不會將使他中斷讀取的字元移出stream，造成scanf(“%c”)吃到原本要讓%d中斷的字(也就是’\n’)</p>
<h2 id="幾種可行的解決方法"><a href="#幾種可行的解決方法" class="headerlink" title="幾種可行的解決方法"></a>幾種可行的解決方法</h2><ol>
<li><p>告訴scanf省略掉下一個垃圾字元再做%c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %c&quot;</span>,&amp;a,&amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;|%d  %c|&quot;</span>, a, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用一個空的scanf(“%c”)吸收掉垃圾字元:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;c);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;|%d  %c|&quot;</span>, a, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用一個空的其他function吸收掉垃圾字元:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">    fgetc(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;|%d  %c|&quot;</span>, a, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="scanf的行為"><a href="#scanf的行為" class="headerlink" title="scanf的行為"></a>scanf的行為</h1><p>scanf在看到不同的<strong>conversion format</strong>，會有不同的反應，而正是這些處理方法的不同導致了奇怪的結果產生。下面分別討論scanf %d跟%c的反應:</p>
<h2 id="scanf-“-d”"><a href="#scanf-“-d”" class="headerlink" title="scanf(“%d”)"></a>scanf(“%d”)</h2><ul>
<li><p>在看到%d時，scanf會略過所有的換行&#x2F;空白字元，直至碰到第一個非換行&#x2F;空白字元才開始讀取，並讀取直到碰到下一個非數字字元、換行&#x2F;空白字元並結束，並留下使他結束讀取的那個字元在stream；</p>
</li>
<li><p>如果碰到的第一個非換行&#x2F;空白字元不是數字(範例2)，scanf函數**會整個結束掉(包括後續的讀取)**，且不會設置errno(perror出來是Success)</p>
</li>
<li><p><strong>範例1</strong> :現在input stream裡面有<code>&quot;\n\n 32X \n&quot;</code>，則scanf(“%d”)以後他會讀取到32這個數字，input stream剩下<code>&quot;X \n&quot;</code> (前面的”\n\n”被無視且吃掉了)</p>
</li>
<li><p><strong>範例2</strong> :現在input stream裡面有<code>&quot;\n XD\n \n&quot;</code>，則scanf(“%d%c”)以後他會在讀到’X’的時候發生錯誤，直接結束整行的scanf(%c也會因此讀不到東西)，此時的input stream剩下<code>&quot;XD\n \n&quot;</code></p>
</li>
</ul>
<h2 id="scanf-“-c”"><a href="#scanf-“-c”" class="headerlink" title="scanf(“%c”)"></a>scanf(“%c”)</h2><ul>
<li><p>在看到%c時，scanf會「無條件」吃下下一個位元並返回(不管是’ ‘還是’\n’或是’\r\n’)</p>
</li>
<li><p>常常是吃到垃圾字的受害者</p>
</li>
</ul>
<h1 id="小測試"><a href="#小測試" class="headerlink" title="小測試"></a>小測試</h1><ul>
<li>如果我們輸入”32X\n”，在一開始的程式碼也會成功喔!</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://laxiflora.github.io/2023/04/29/%E6%B7%BA%E8%AB%87c-c-%E7%9A%84VLA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="劉宇承">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/29/%E6%B7%BA%E8%AB%87c-c-%E7%9A%84VLA/" class="post-title-link" itemprop="url">淺談c/c++的VLA</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2023-04-29 17:01:42 / 修改時間：22:26:37" itemprop="dateCreated datePublished" datetime="2023-04-29T17:01:42+08:00">2023-04-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="在C-傳遞二維VLA的難題"><a href="#在C-傳遞二維VLA的難題" class="headerlink" title="在C++傳遞二維VLA的難題"></a>在C++傳遞二維VLA的難題</h1><p>在寫某題leetcode時，碰到了需要宣告2維陣列，且陣列大小是變數的狀況。因為自己本身習慣使用VLA(variable-length arrays)，所以理所當然的宣告了二維陣列，並將他丟入函式處理，格式如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> y_axis, <span class="type">bool</span> map[][y_axis])</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> map[x_axis][y_axis];</span><br><span class="line"><span class="built_in">foo</span>(y_axis, map)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>值得注意的是，如果把argument map放在y_axis前面的話，會造成編譯器先看到map然後無法解讀y_axis (未宣告的變數)</p>
</blockquote>
<p>這個方法在C中行得通，然而在C++會跳出錯誤訊息:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: use of parameter outside function body before ‘]’ token</span><br><span class="line">    <span class="number">3</span> | <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> array[][n])</span></span>&#123;</span><br></pre></td></tr></table></figure>

<p>若是把map改成bool**作為參數，則會:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> y_axis, <span class="type">bool</span>** map)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">error: cannot convert ‘<span class="built_in">int</span> (*)[n]’ to ‘<span class="type">int</span>**’</span><br><span class="line">   <span class="number">11</span> |     <span class="built_in">foo</span>(n, array);</span><br></pre></td></tr></table></figure>


<p>但如果陣列的大小是常數，卻可以編譯通過</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> (*array)[<span class="number">3</span>])</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    std::cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> array[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">foo</span>(n, array);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看來問題出在C++中，多維陣列的local宣告不可用變數作為參數(VLA)</p>
<p>嗯? 你說你在C++可以用<code>int array[m][n];</code>宣告成功並使用，只是不能丟入函數? 這其實只是編譯器給你行方便而已，GPT給出了回答:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C++ does not support variable-length arrays (VLA) as a language feature, unlike C99 which introduced VLAs as a standard feature. However, some C++ compilers may offer support for VLAs as an extension, allowing you to declare and use them in your code.</span><br><span class="line"></span><br><span class="line">The ability to declare a VLA 2D array like int array[m][n] in C++ may be possible because some C++ compilers may allow it as an extension to the language. However, the behavior of such extensions can vary between different compilers, and they may not be portable across different platforms or architectures.</span><br><span class="line"></span><br><span class="line">It&#x27;s important to note that relying on such extensions may not be the best approach for writing portable and maintainable C++ code. Instead, it&#x27;s recommended to use alternative approaches for dynamically allocating memory, such as using the std::vector container or dynamic memory allocation with the new and delete operators. These approaches provide more portable and flexible solutions for dynamically allocating memory in C++.</span><br></pre></td></tr></table></figure>


<h1 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h1><p>C++相對於把動態變換大小的資料存放在stack，更鼓勵將資料放在heap中，方法是透過vector STL或是new pointer:</p>
<blockquote>
<p>C++中vector元素的存放位置是heap，push_back元素時實際上new了一個新object</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用new的</span></span><br><span class="line"><span class="type">int</span>** a = <span class="keyword">new</span> <span class="type">int</span>*[x_axis];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; x_axis; ++i)</span><br><span class="line">    a[i] = <span class="keyword">new</span> <span class="type">int</span>[y_axis];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用vector，因為vector是動態延展大小，所以這裡包含了輸入</span></span><br><span class="line">vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; a;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x_axis;i++)&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; newRow;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;y_axis;j++)&#123;</span><br><span class="line">        <span class="type">int</span> input;</span><br><span class="line">        cin&gt;&gt;input;</span><br><span class="line">        newRow.<span class="built_in">push_back</span>(input);</span><br><span class="line">    &#125;</span><br><span class="line">    a.<span class="built_in">push_back</span>(newRow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="為什麼會這樣"><a href="#為什麼會這樣" class="headerlink" title="為什麼會這樣"></a>為什麼會這樣</h1><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1887097/why-arent-variable-length-arrays-part-of-the-c-standard">這裡給出了解釋</a>，大致是說如果直接宣告的話，第一可能有stack overflow的風險(將stack allocation交由輸入者決定是危險的)，第二則是對於編譯器實作會有額外的負擔，必須在run time才能知道stack要被allocate多少大小</p>
<p>當然，這也有一定的trade-off，如果我們將資料放在heap中，相比於記憶體地址連續的stack，或多或少會傷害到cache performance(當然還是要看CPU的實作)，且要allocate in stack只要延伸sp指的位置就好，不像<code>new</code>還要跟記憶體互動</p>
<p>不過，傳統的C99是允許VLA的，現今常見的編譯器(gcc, clang等)都有支援基本的VLA，但要注意的是<em>這不是C++的standard</em>，而是來自於編譯器的extention，將C++的宣告方法轉成C風格、支援VLA的格式</p>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>如果要用C++寫程式，就善用STL容器吧。</p>
<p>C++與C對於相同的概念，有不同的實作方式：C++希望設計師使用他們提供的解方(STL)來解決問題；C則更相信程式設計師知道自己在幹嘛(有stack overflow的風險)，但提供自由與看似方便的宣告方法的背後，就是程式莫名崩潰的風險。</p>
<p>別被C允許VLA的開發方式慣壞了，為了讓程式更安全並兼顧速度，根據使用狀況判斷使用heap還是stack來存放資料是好習慣</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://laxiflora.github.io/2022/12/21/111-1-%E4%BA%A4%E5%A4%A7%E7%B6%B2%E8%B7%AF%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="劉宇承">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/21/111-1-%E4%BA%A4%E5%A4%A7%E7%B6%B2%E8%B7%AF%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/" class="post-title-link" itemprop="url">111-1 交大網路程式設計</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2022-12-21 02:41:19 / 修改時間：02:42:43" itemprop="dateCreated datePublished" datetime="2022-12-21T02:41:19+08:00">2022-12-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>只簡介作業的眉角，畢竟課堂的本體是作業orz</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://laxiflora.github.io/2022/12/21/%E4%BA%A4%E5%A4%A7%E7%B6%B2%E8%B7%AF%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="劉宇承">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/21/%E4%BA%A4%E5%A4%A7%E7%B6%B2%E8%B7%AF%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/" class="post-title-link" itemprop="url">交大網路程式設計</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2022-12-21 02:38:50 / 修改時間：02:39:41" itemprop="dateCreated datePublished" datetime="2022-12-21T02:38:50+08:00">2022-12-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://laxiflora.github.io/2022/10/15/char-%E7%9A%84%E5%A5%A7%E7%A7%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="劉宇承">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/15/char-%E7%9A%84%E5%A5%A7%E7%A7%98/" class="post-title-link" itemprop="url">char*的奧秘</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2022-10-15 02:41:50 / 修改時間：03:58:44" itemprop="dateCreated datePublished" datetime="2022-10-15T02:41:50+08:00">2022-10-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>這篇文主要想要強調的就是，char*作為一個指標，紀錄的是記憶體位址，若指向的記憶體地址沒有被分配，是不可以直接用strcpy的</p>
<p>char[]其實就是一個數組，雖然看似跟char*一樣，但兩者的邏輯不同</p>
<h2 id="char"><a href="#char" class="headerlink" title="char[]"></a>char[]</h2><p><code>char a[] = &quot;KKK&quot;</code> 其實等同於<code>char a[] = &#123;&#39;K&#39;,&#39;K&#39;,&#39;K&#39;,&#39;\0&#39;&#125;</code><br>如果用vs code滑上去看，會發現它其實就是char a[4]<br><img src="/../images/20221015_1.png"></p>
<p>這類型的變數在宣告時就必須給定字元，且後續長度不可修改。</p>
<blockquote>
<p>即，不能用<code>char a[] = &quot;KKK&quot;;  a = &quot;KKKKK&quot;;</code></p>
</blockquote>
<p>這時候它的操作等同於char[n]，要改變其中任意「字元」都是可行的(此變數已經作為array被分配在stack中)<br>但當然如果把最後的’\0’換成其他字元，<code>printf(&quot;%s&quot;)</code>會印出奇怪的東西</p>
<p>至於char* argv[]，同理其實只是等同於<code>char* argv[n] = &#123;&#39;string1&#39;,&#39;string2&#39;,...&#125;</code>而已</p>
<p>要注意的是不可以直接把整個array改成其他字串，在C語言規範中arrays並非modifiable l-values</p>
<p>如果要修改這類的char陣列，須使用<code>strcpy</code> (用malloc&#x2F;new出來的char array同理)</p>
<p>這類char陣列的size是根據字元數變動的</p>
<h2 id="char-1"><a href="#char-1" class="headerlink" title="char*"></a>char*</h2><p>顧名思義，他其實是字元指標，指向某個字串常數的指標。</p>
<p>C&#x2F;C++的常數字串儲存方法是為這些字串開一個空間存放他們，當宣告</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* A = <span class="string">&quot;hey&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>時，其實就是為hey這個字串分配一個空的記憶體位置，並且將A指向這個地址。</p>
<blockquote>
<p>也就是說，如果哪天”hey”的值變動了，A的內容也會跟著變動! 同時char*可以指向任意大小的char[]，但只要char[]內容更動，char*也會受到影響</p>
</blockquote>
<p>因為這個特性，char*不同於char[]，他是可以在後天改值的，只要改變他指的地址即可。</p>
<ul>
<li>char*就是浮萍，不像char[]、malloc()出來的char*一樣攜家帶眷</li>
</ul>
<p>不過，也因為他是單單一個指向記憶體的指標，我們不能透過strcpy等函數塞整個char array給他，他的空間尚未被初始化，如果直接用strcpy很可能導致SEG Falut</p>
<p>而且因為類別正確(strcpy的確是接受char*作為參數)，所以編譯器<strong>並不會警告</strong>，新手在看文件時也會看到輸入參數是char*就傻傻地把char*丟進去了</p>
<p>最後，char*如果沒有被初始化(指向某個常數字串)而直接印出，也會SEG fault</p>
<ul>
<li>這類char指標的size是根據作業系統的位元數變動的</li>
</ul>
<h2 id="char-2"><a href="#char-2" class="headerlink" title="char *[]"></a>char *[]</h2><p>根據<a href="/2022/10/15/C-C-%E5%AE%A3%E5%91%8A%E9%96%B1%E8%AE%80%E6%B3%95/">C&#x2F;C++宣告閱讀法</a>，以下面的變數為範例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char* hard[3];</span><br></pre></td></tr></table></figure>
<p>我們可以得到他是「hard is size-3 array of pointers to char 」，也就是3個char*。因此我們我們可以套用char*的作法，hard這個變數是不能被strcpy的(不會有任何警告但會SAG fault)</p>
<h2 id="額外補充"><a href="#額外補充" class="headerlink" title="額外補充"></a>額外補充</h2><p>另一個常見的SEG fault的原因就是生命週期</p>
<p>考慮以下code</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">char</span>* in)</span>&#123;</span><br><span class="line">    <span class="type">char</span> ans[] = <span class="string">&quot;laugh&quot;</span>;</span><br><span class="line">    in = ans; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nin funct, aram = %s\n&quot;</span>,in);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">    <span class="type">char</span>* aram;</span><br><span class="line">    foo(aram);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nout funct, aram = %s\n&quot;</span>,aram);</span><br></pre></td></tr></table></figure>

<p>我們應該會期望得到輸出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in funct, aram = laugh</span><br><span class="line">out funct, aram = laugh</span><br></pre></td></tr></table></figure>

<p>但結果卻是SEG fault</p>
<p>因為ans作為foo函數的區域變數，在退出函數時就已經消滅了，當aram變數還指向他的時候，其實會出現未定義行為</p>
<p>所以如果想要讓aram保存ans的結果，最好的做法就是用malloc的，如下code</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">char</span>* in)</span>&#123;</span><br><span class="line">    <span class="type">char</span> ans[] = <span class="string">&quot;laugh&quot;</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(in,ans);  <span class="comment">//注意要改成strcpy!</span></span><br><span class="line">   <span class="comment">// in = ans; </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nin funct, aram = %s\n&quot;</span>,in);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">    <span class="type">char</span>* aram;</span><br><span class="line">    aram = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">16</span>); <span class="comment">//讓aram變成malloc變數，可以「攜家帶眷」</span></span><br><span class="line">    foo(aram);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nout funct, aram = %s\n&quot;</span>,aram);</span><br></pre></td></tr></table></figure>

<p>Note: 如果aram在丟入foo以後才malloc，仍會因為命名問題消滅造成SEG fault!!</p>
<p>如果想要在函數內進行malloc，則需要傳入aram的地址，如下code</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">char</span>** in)</span>&#123;</span><br><span class="line">    <span class="type">char</span> ans[] = <span class="string">&quot;laugh&quot;</span>;</span><br><span class="line">    *in = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">16</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(*in,ans);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nin funct, aram = %s\n&quot;</span>,*in);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">    <span class="type">char</span>* aram;</span><br><span class="line">    foo(&amp;aram); <span class="comment">//改這裡</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nout funct, aram = %s\n&quot;</span>,aram);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://laxiflora.github.io/2022/10/15/C-C-%E5%AE%A3%E5%91%8A%E9%96%B1%E8%AE%80%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="劉宇承">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/15/C-C-%E5%AE%A3%E5%91%8A%E9%96%B1%E8%AE%80%E6%B3%95/" class="post-title-link" itemprop="url">C/C++宣告閱讀法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2022-10-15 02:39:08 / 修改時間：02:40:25" itemprop="dateCreated datePublished" datetime="2022-10-15T02:39:08+08:00">2022-10-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>來源: <a target="_blank" rel="noopener" href="https://cseweb.ucsd.edu/~ricko/rt_lt.rule.html">The “right-left” rule</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://laxiflora.github.io/2022/10/10/C-pipe%E8%88%87buffer-overflow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="劉宇承">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/10/C-pipe%E8%88%87buffer-overflow/" class="post-title-link" itemprop="url">C++ pipe與buffer overflow</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2022-10-10 23:28:56" itemprop="dateCreated datePublished" datetime="2022-10-10T23:28:56+08:00">2022-10-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新於</span>
      <time title="修改時間：2022-10-11 00:15:31" itemprop="dateModified" datetime="2022-10-11T00:15:31+08:00">2022-10-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本篇主要講述C++中<code>pipe()</code>函數的相關行為</p>
<p>因為pipe的buffer大小並非無限大，如果輸入流資料量過大，很有可能會碰到buffer塞滿而輸入還沒結束的問題<br>寫了以下的code來測試pipe buffer如果塞爆了會發生甚麼事情</p>
<h1 id="實驗"><a href="#實驗" class="headerlink" title="實驗"></a>實驗</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// 創造pipe</span></span><br><span class="line">    <span class="type">int</span> my_pipe[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pipe</span>(my_pipe) == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error creating pipe\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//-------------------------</span></span><br><span class="line">    <span class="type">pid_t</span> child_id;</span><br><span class="line">    child_id = fork();</span><br><span class="line">    <span class="keyword">if</span>(child_id == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Fork error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 創造一個子process，將buffer塞爆</span></span><br><span class="line">    <span class="keyword">if</span>(child_id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(my_pipe[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">dup2</span>(my_pipe[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        string some = <span class="string">&quot;something&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000000000000000</span>;i++)&#123;</span><br><span class="line">            cout&lt;&lt;some;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Chind,finished&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//---------------------------------</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="type">int</span> aaa = fork();</span><br><span class="line">        <span class="comment">// 再創造一個子process，讓他先sleep 4秒以後再嘗試在已經被塞爆的buffer寫入</span></span><br><span class="line">        <span class="keyword">if</span>(aaa == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">4</span>);</span><br><span class="line">            <span class="built_in">close</span>(my_pipe[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1999</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Child2 round &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                <span class="built_in">write</span>(my_pipe[<span class="number">1</span>],<span class="string">&quot;NP&quot;</span>,<span class="built_in">sizeof</span>(<span class="string">&quot;NP&quot;</span>));  <span class="comment">// is stuck because of the fullness of pipe</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//----------------------------</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原本的父process，先sleep 10秒讓我們觀察child process被塞爆的現象再read一些東西來疏通pipe，但這樣的量不足以讀完所有的input</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">close</span>(my_pipe[<span class="number">1</span>]); <span class="comment">// parent doesn&#x27;t write</span></span><br><span class="line"></span><br><span class="line">            <span class="type">char</span> reading_buf[<span class="number">1000</span>]=&#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">                <span class="built_in">read</span>(my_pipe[<span class="number">0</span>], reading_buf, <span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等待第一次fork出來的子process</span></span><br><span class="line">    <span class="built_in">wait</span>(&amp;child_id);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//這行永遠不會印出來，因為子process永遠不會輸出完成而結束</span></span><br><span class="line">    cout&lt;&lt;my_pipe[<span class="number">0</span>]&lt;&lt;my_pipe[<span class="number">1</span>]; <span class="comment">//3,4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>實際編譯執行後，出現以下結果<br><img src="/../images/20221010_2.png" alt="upload successful"><br>Child2卡在第1897次輸出就寫不下去了，當然第一個process也是卡住的狀態(見Ps)</p>
<h1 id="Pipe特性"><a href="#Pipe特性" class="headerlink" title="Pipe特性"></a>Pipe特性</h1><p>從這個小實驗可以知道一些事情</p>
<ul>
<li><p>pipe的buffer有限，是會被塞爆的</p>
</li>
<li><p>原生的pipe如果被寫滿，會讓想繼續寫入的<strong>所有process</strong>被卡住不能繼續執行，直到pipe被讀取</p>
<ul>
<li>不可以wait process完整寫入發signal以後才fork另一個process再讀取，這樣很可能導致整個程式卡死<br>    - 如果卡住的process太多，可能會讓父process再也fork不出東西來讓本該讀取的process去接，造成整個程式卡死</li>
</ul>
</li>
<li><p>要注意針對大資料的處理，pipe應該要有個”抒發管道”，不能期待他真的裝下全世界</p>
</li>
</ul>
<h2 id="補充"><a href="#補充" class="headerlink" title="補充"></a>補充</h2><p>我另外做了一個反向實驗:<br>    讓輸入資料的process延遲輸入，而讀取的process開始讀空的pipe，得到以下心得</p>
<ul>
<li>讀取端會等read(fd,char* buffer,int size)裡面的size被填滿才會執行接下來的動作<ul>
<li>想到以前上課老師說的，只要<strong>還有process 對pipe的輸入端還未關閉</strong>，讀取端就會一直認為有東西要進來，而呆呆地等 -&gt; 關不用的stream很重要!</li>
</ul>
</li>
</ul>
<p>P.S<br>測試這個東西的時候還有用背景執行，創造了不少卡著的process<br><img src="/../images/20221010_1.png"><br>其中相連的pid可以看出來是同一個程式來的，原本的父process，連帶所有child process都無法被正常結束…</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://laxiflora.github.io/2022/10/09/%E7%94%A8std-string%E5%81%9Astrtok/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="劉宇承">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/09/%E7%94%A8std-string%E5%81%9Astrtok/" class="post-title-link" itemprop="url">用std::string做strtok</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2022-10-09 17:16:11 / 修改時間：17:36:08" itemprop="dateCreated datePublished" datetime="2022-10-09T17:16:11+08:00">2022-10-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>參考資料: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/289347/using-strtok-with-a-stdstring">stackoverflow</a></p>
<h1 id="用std-string做strtok"><a href="#用std-string做strtok" class="headerlink" title="用std::string做strtok"></a>用std::string做strtok</h1><p>由於C++的string type並不支援strtok的功能，所以如果想要將C++的string做切段，有以下幾種方法:</p>
<h2 id="法1-用istringstream"><a href="#法1-用istringstream" class="headerlink" title="法1: 用istringstream"></a>法1: 用istringstream</h2><p>使用<a target="_blank" rel="noopener" href="https://cplusplus.com/reference/sstream/istringstream/istringstream/">stringstream類別</a>，使用方法就像C++風格的iostream一樣，只是這個stream不是stdin&#x2F;stdout，也不是fstream，而是將string的內容倒入一個stream (因此不具有fd–待查證)。</p>
<p>將要切割的字串倒入stream以後，再用getline中的Delimiter參數做為切割標準即可<br>參考程式碼片段如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">char</span> delimiter)</span></span>&#123;</span><br><span class="line">   vector&lt;string&gt; tokens;</span><br><span class="line">   string token;</span><br><span class="line">   <span class="function">istringstream <span class="title">tokenStream</span><span class="params">(s)</span></span>;</span><br><span class="line">   <span class="keyword">while</span> (<span class="built_in">getline</span>(tokenStream, token, delimiter))&#123;</span><br><span class="line">      tokens.<span class="built_in">push_back</span>(token);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> tokens;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// tokens vector裝的是切割完的string</span></span><br></pre></td></tr></table></figure>


<h2 id="法2-先把string轉成char-以後再切割"><a href="#法2-先把string轉成char-以後再切割" class="headerlink" title="法2: 先把string轉成char*以後再切割"></a>法2: 先把string轉成char*以後再切割</h2><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/289347/using-strtok-with-a-stdstring">參考資料</a><br>如果要將string轉換成char*，可以透過<code>string.c_str()</code>函數</p>
<p>這個方法其實不太推薦，他是把C++風格棄掉，強制使用strtok來處理字串<br>參考程式碼片段如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//given string str as a string needed to slice</span></span><br><span class="line"><span class="type">char</span> *dup = <span class="built_in">strdup</span>(str.<span class="built_in">c_str</span>());</span><br><span class="line">token = <span class="built_in">strtok</span>(dup, <span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(dup);</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://laxiflora.github.io/2022/08/17/ML-2021-12-1-%E5%A2%9E%E5%BC%B7%E5%BC%8F%E5%AD%B8%E7%BF%92%E8%B7%9F%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92%E4%B8%80%E6%A8%A3%E9%83%BD%E6%98%AF%E4%B8%89%E5%80%8B%E6%AD%A5%E9%A9%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="劉宇承">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/17/ML-2021-12-1-%E5%A2%9E%E5%BC%B7%E5%BC%8F%E5%AD%B8%E7%BF%92%E8%B7%9F%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92%E4%B8%80%E6%A8%A3%E9%83%BD%E6%98%AF%E4%B8%89%E5%80%8B%E6%AD%A5%E9%A9%9F/" class="post-title-link" itemprop="url">ML_2021_12-1 增強式學習跟機器學習一樣都是三個步驟</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2022-08-17 13:15:48 / 修改時間：19:31:50" itemprop="dateCreated datePublished" datetime="2022-08-17T13:15:48+08:00">2022-08-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://laxiflora.github.io/2022/08/15/ML-2021-11-1-%E6%A6%82%E8%BF%B0%E9%A0%98%E5%9F%9F%E8%87%AA%E9%81%A9%E6%87%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="劉宇承">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | laxiflora的小天地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/15/ML-2021-11-1-%E6%A6%82%E8%BF%B0%E9%A0%98%E5%9F%9F%E8%87%AA%E9%81%A9%E6%87%89/" class="post-title-link" itemprop="url">ML_2021_11-1 概述領域自適應</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2022-08-15 01:58:17" itemprop="dateCreated datePublished" datetime="2022-08-15T01:58:17+08:00">2022-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新於</span>
      <time title="修改時間：2022-08-17 19:31:50" itemprop="dateModified" datetime="2022-08-17T19:31:50+08:00">2022-08-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Train跟testing data之間可能會有不同的分佈 -&gt; <strong>domain shift</strong></p>
<p>ex. 用黑白圖片訓練數字辨識，但測試資料使用彩色圖片，則命中率會大幅降低</p>
<h1 id="Domain-shift的種類"><a href="#Domain-shift的種類" class="headerlink" title="Domain shift的種類"></a>Domain shift的種類</h1><ul>
<li>不只是輸入資料的特性不合</li>
<li>可能輸出的資料，其機率分佈不一樣</li>
<li>或是也許在測試資料裡面，雖然圖樣跟訓練資料很像，但是它所代表的意涵卻不一樣<br><img src="/../images/20220817_1.png"></li>
</ul>
<h1 id="Domain-adaptation"><a href="#Domain-adaptation" class="headerlink" title="Domain adaptation"></a>Domain adaptation</h1><ul>
<li>可以看作是transfer learning的一種</li>
<li>我們會需要對target domain有一些了解</li>
</ul>
<h2 id="Case-1-有target-domain的labeled資料但資料量很少"><a href="#Case-1-有target-domain的labeled資料但資料量很少" class="headerlink" title="Case 1:有target domain的labeled資料但資料量很少"></a>Case 1:有target domain的labeled資料但資料量很少</h2><ul>
<li>用類似BERT的fine-tune方法來微調一下model</li>
<li>但target domain資料量很少，所以很容易overfitting<ul>
<li>限制fine-tune前後的參數變化量<br>    - 降低lr<br>    - 限制epoch數</li>
</ul>
</li>
</ul>
<h2 id="Case-2-有一大堆target-domain的unlabeled資料"><a href="#Case-2-有一大堆target-domain的unlabeled資料" class="headerlink" title="Case 2:有一大堆target domain的unlabeled資料"></a>Case 2:有一大堆target domain的unlabeled資料</h2><ul>
<li>本課的討論重點</li>
<li>在實務上比較有常發生</li>
<li>Idea:用一個feature extractor把source跟target domain的不同點刪除，擷取出共同的部分<ul>
<li>Ex.數字辨識，學習去忽略圖片顏色</li>
</ul>
</li>
</ul>
<h3 id="Domain-Adversarial-training"><a href="#Domain-Adversarial-training" class="headerlink" title="Domain Adversarial training"></a>Domain Adversarial training</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li><p>我們會訓練出一個new image classifier model，其中前半部分是feature extractor，後半部則是label predictor<br><img src="/../images/20220817_2.png"></p>
</li>
<li><p>我們會希望feature extractor的輸出（上圖右下角的分佈圖），source跟target domain的分佈看不出差異</p>
</li>
<li><p>由feature extractor跟domain classifier互相對抗，將feature extractor的輸出送到domain classifier，domain classifier要想辦法辨認出這個輸出是來自source還是target domain</p>
</li>
<li><p>feature extractor -&gt; Generator &amp; domain classifier -&gt; Discriminator</p>
</li>
<li><p>但這樣對於feature extractor優勢太大，因為只要他都輸出0，就可以讓domain classifier被輕鬆騙過去 -&gt; 讓label Predictor也加入戰局</p>
</li>
</ul>
<h4 id="計算方法"><a href="#計算方法" class="headerlink" title="計算方法"></a>計算方法</h4><p>令</p>
<ol>
<li>Feature extractor的參數為$\theta_f$</li>
<li>Label Predictor的參數為$\theta_p$</li>
<li>Domain Classifier的參數為$\theta_d$</li>
<li>輸出圖片預測結果與真實結果的loss(cross entropy)為$L$</li>
<li>Domain Classifier二元分類器的輸出loss為$L_d$</li>
</ol>
<p>因為我們同時希望Label Predictor分類越正確越好，又同時希望domain classifier能被騙過。則可以得出一個最佳化feature extractor的公式（非正確，勿照抄）<br>$$<br>\theta_f^* &#x3D; min_{\theta_f}\ L-L_d<br>$$</p>
<p>問題來了，如果我們直接套用這個公式，會導致$L_d$越大越好（也就是讓domain classifier的loss飆高），這可能讓feature extractor變成努力讓domain classifier把target看成source，source看成target，而這也是某種程度上的分隔開兩個domain</p>
<p>如何改善公式，留給大家思考orz</p>
<p>domain adversarial training的效果拔群<br><img src="/../images/20220817_3.png"></p>
<h3 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a>Limitation</h3><p><img src="/../images/20220817_5.png"><br>由上面的公式，我們可以練出上圖兩種類型的model滿足上面的公式，但是可以明顯看出，右邊的分佈會比左邊還好</p>
<p>我們雖然不知道橘色(target domain)的label為何，但我們知道藍色(source)資料的分界線，因此我們要在這樣的前提下，想辦法也讓橘色的資料被該分界線劃清</p>
<ul>
<li>有很多相關方法<ul>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1802.08735">參考文獻：DIRT-T</a></li>
<li>一種簡單的方向是確保unlabeled data丟入label predictor後輸出的分佈越集中越好<br><img src="/../images/20220817_6.png"></li>
</ul>
</li>
</ul>
<h2 id="Case-3：雖然Target-domain-unlabeled-data很多，但Source跟Target-domain的class集合不同"><a href="#Case-3：雖然Target-domain-unlabeled-data很多，但Source跟Target-domain的class集合不同" class="headerlink" title="Case 3：雖然Target domain unlabeled data很多，但Source跟Target domain的class集合不同"></a>Case 3：雖然Target domain unlabeled data很多，但Source跟Target domain的class集合不同</h2><p>到目前為止，我們都假設target跟source domain的類別集合是一樣的</p>
<p>如果類別集合不同，則硬要align data可能會反導致兩個無關的class被綁在一起 $\rightarrow$ <strong>Universal domain adaptation</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://openaccess.thecvf.com/content_CVPR_2019/html/You_Universal_Domain_Adaptation_CVPR_2019_paper.html">參考文獻</a></li>
</ul>
<h2 id="Case-4：Target-domain-unlabeled-data也很少"><a href="#Case-4：Target-domain-unlabeled-data也很少" class="headerlink" title="Case 4：Target domain unlabeled data也很少"></a>Case 4：Target domain unlabeled data也很少</h2><ul>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1909.13231">Testing time training(TTT)</a></li>
</ul>
<h2 id="Case-5：我啥都不知道QQ"><a href="#Case-5：我啥都不知道QQ" class="headerlink" title="Case 5：我啥都不知道QQ"></a>Case 5：我啥都不知道QQ</h2><ul>
<li>Domain Generalization<ul>
<li>訓練資料豐富，包含各種domain（ex. 貓狗分類，除了真貓真狗以外還有素描、卡通畫風）<br>    	- <a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/8578664">參考文獻</a><br>    - 訓練資料不豐富，但測試資料很豐富(有點像想辦法做data augmentation)<br>    	- <a target="_blank" rel="noopener" href="https://arxiv.org/abs/2003.13216">參考文獻</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一頁"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">劉宇承</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 強力驅動
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
